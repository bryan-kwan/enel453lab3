
module averager #(parameter 
                INWIDTH=16,
                LOGMEMSIZE=8, // Log base 2 of the size of memory (ie how many samples to average)
                OUTWIDTH=16, // Same as INWIDTH if accurate rounding is not required (truncation is ok)
                MEMSIZE=2**LOGMEMSIZE // Number of samples to average
                )
                (input  logic           clk,
                                        EN,      // takes a new sample when high for each clock cycle
                                        reset_n,
                input  logic [INWIDTH-1:0]   Din,     // input sample for moving average calculation
                output logic [OUTWIDTH-1:0]   Q);

// Algorithm:
//	y[n] = y[n-1] + x[n] - x[n-navg]
// Pipeline: 
//  0   newaddr, oldaddr
//  1   newval, oldval
//  2   sum
//  3   Q

// Overall delay of 4 samples. One to set the read/write address; one to read the new/old values and write
// the new sample; one to compute the new sum; one to take the average (Q).

    logic [LOGMEMSIZE-1:0] newaddr, oldaddr; // Addresses of newest and oldest values
    logic [INWIDTH-1:0] memory [MEMSIZE-1:0]; // Memory of size MEMSIZE for data of size INWIDTH-1
    logic [INWIDTH-1:0] oldval, newval; // Oldest value and newest value
    logic [MEMSIZE*INWIDTH:0] sum; // Sum of all values

    always_ff @(posedge clk, negedge reset_n)
        if(~reset_n) begin
            Q<={OUTWIDTH}{1'b0};
            newaddr<={LOGMEMSIZE}{1'b0}; // Start writing new values at address 0
            oldaddr<={{LOGMEMSIZE-1}{1'b0},1'b1}; // Start reading old values from address 1
            sum<={MEMSIZE*INWIDTH}{1'b0}; // Sum starts at 0
            for(int i=0;i<MEMSIZE;i++)
                memory[i] <= {INWIDTH}{1'b0}; // Initialize memory to all zeros
        end
        else if (EN) begin
            oldval <= memory[oldaddr];
            newval <= memory[newaddr]; // Note newval does not get Din (gets value before Din is written)
            memory[newaddr] <= Din;
            oldaddr<= oldaddr + 1'b1; // Increment our addresses
            newaddr<= newaddr + 1'b1; // Due to overflow, this creates a circular queue
            sum <= sum + newval - oldval; // Add the new value and subtract the old value
            Q <= sum / MEMSIZE; // average = sum / number_of_samples (same as a shift since MEMSIZE is a power of 2)
        end

endmodule