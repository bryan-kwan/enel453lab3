`timescale 1ns/1ps

module top_level_tb();
	logic clk=0;
	logic reset_n, store;
	logic [9:0] SW, LEDR;
	logic [7:0] HEX0, HEX1, HEX2, HEX3, HEX4, HEX5;
	int digit0, digit1, digit2, digit3;
	logic write_enable_n;

	parameter CLOCK_PERIOD = 20;
	parameter delay = 6*CLOCK_PERIOD;
	time debouncer_stable_time = 5000000*CLOCK_PERIOD;
	// Instantiate UUTs
	//(input  logic       clk,
	//  input  logic       reset_n,
	//  input  logic [9:0] SW,
	//  output logic [9:0] LEDR,
	//  output logic [7:0] HEX0,HEX1,HEX2,HEX3,HEX4,HEX5);

	top_level UUT(.clk(clk),.reset_n(reset_n), 
	.SW(SW),.LEDR(LEDR), .store(store),
	.HEX0(HEX0),.HEX1(HEX1),
	.HEX2(HEX2),.HEX3(HEX3),
	.HEX4(HEX4),.HEX5(HEX5));

	// Function to check correct seven segment value for a given number
	// Returns 1 if segment is correct, else returns 0
	function int segment_is_correct(int digit, logic[6:0] display);
		segment_is_correct=1;
		case(digit)
				0: assert(display[6:0]===~7'b0_11_11_11) else segment_is_correct=0;
				1: assert(display[6:0]===~7'b0_00_01_10) else segment_is_correct=0;
				2: assert(display[6:0]===~7'b1_01_10_11) else segment_is_correct=0;
				3: assert(display[6:0]===~7'b1_00_11_11) else segment_is_correct=0;
				4: assert(display[6:0]===~7'b1_10_01_10) else segment_is_correct=0;
				5: assert(display[6:0]===~7'b1_10_11_01) else segment_is_correct=0;
				6: assert(display[6:0]===~7'b1_11_11_01) else segment_is_correct=0;
				7: assert(display[6:0]===~7'b0_00_01_11) else segment_is_correct=0;
				8: assert(display[6:0]===~7'b1_11_11_11) else segment_is_correct=0;
				9: assert(display[6:0]===~7'b1_10_01_11) else segment_is_correct=0;
				10: assert(display[6:0]===~7'b1_11_01_11) else segment_is_correct=0;
				11: assert(display[6:0]===~7'b1_11_11_00) else segment_is_correct=0;
				12: assert(display[6:0]===~7'b0_11_10_01) else segment_is_correct=0;
				13: assert(display[6:0]===~7'b1_01_11_10) else segment_is_correct=0;
				14: assert(display[6:0]===~7'b1_11_10_01) else segment_is_correct=0;
				15: assert(display[6:0]===~7'b1_11_00_01) else segment_is_correct=0;
		endcase
	endfunction
	// Apply stimulus
	always #(CLOCK_PERIOD/2) clk = ~clk; // run clock forever with period CLOCK_PERIOD ns 
	
	assign write_enable_n = UUT.register_16_ins.write_enable_n; // Probe for viewing debouncing behaviour
	
	initial begin 
		$display("---  Testbench started  ---");
		
		#(1000*CLOCK_PERIOD); // Long initialization delay
		// Reset tests
		SW[9:8]=2'b00; // Set to decimal mode
		reset_n = 1; #(delay);
		reset_n = 0;#(delay); // Reset is active low
		reset_n = 1; #(delay);
		
		SW[9:8]=2'b01; // Set to hexadecimal mode
		reset_n = 1; #(delay);
		reset_n = 0; #(delay); // Reset is active low
		reset_n = 1; #(delay);
		
		SW[9:8]=2'b10; // Set to stored value mode
		reset_n = 1; #(delay);
		reset_n = 0; #(delay); // Reset is active low
		reset_n = 1; #(delay);
		
		SW[9:8]=2'b11; // Set to fixed output mode
		reset_n = 1; #(delay);
		reset_n = 0; #(delay); // Reset is active low
		reset_n = 1; #(delay);
		
		// Display value tests
		SW[9:8]=2'b00; // Set to decimal mode
		for (int i = 0; i < 256; i++) begin
			SW[7:0]=i; #5000;
			digit0 = i / 10 ** (1 - 1) % 10; // First digit of i in base 10
			digit1= i / 10 ** (2 - 1) % 10; // Second digit
			digit2= i / 10 ** (3 - 1) % 10; // Third digit
			digit3= i / 10 ** (4 - 1) % 10; // Fourth digit
			if(segment_is_correct(digit0, HEX0)===0) $error("Decimal mode failed for value i=%d in HEX0, Num_Hex0=%d",i, UUT.Num_Hex0);
			if(segment_is_correct(digit1, HEX1)===0) $error("Decimal mode failed for value i=%d in HEX1, Num_Hex1=%d",i, UUT.Num_Hex1);
			if(segment_is_correct(digit2, HEX2)===0) $error("Decimal mode failed for value i=%d in HEX2, Num_Hex2=%d",i, UUT.Num_Hex2);
		end
		$display("End of decimal mode test");
		SW[9:8]=2'b01; // Set to hexadecimal mode
		for (int i = 0; i < 256; i++) begin
			SW[7:0]=i; #5000;
			digit0 = i / 16 ** (1 - 1) % 16; // First digit of i in base 16
			digit1= i / 16 **(2 - 1) % 16; // Second digit
			digit2= i / 16 ** (3 - 1) % 16; // Third digit
			digit3= i / 16 ** (4 - 1) % 16; // Fourth digit
			if(segment_is_correct(digit0, HEX0)===0) $error("Hexadecimal mode failed for value %d in HEX0, Num_Hex0=%d",i, UUT.Num_Hex0);
			if(segment_is_correct(digit1, HEX1)===0) $error("Hexadecimal mode failed for value %d in HEX1, Num_Hex1=%d",i, UUT.Num_Hex1);
			if(segment_is_correct(digit2, HEX2)===0) $error("Hexadecimal mode failed for value %d in HEX2, Num_Hex2=%d",i, UUT.Num_Hex2);
		end
		$display("End of hexadecimal mode test");
		// Stored value tests
			// Decimal storage
			store=1;
			SW[9:8]=2'b00; // Set to decimal mode
			SW[7:0]=8'b0101_1010; #5000; // 5A
			store=1; #(CLOCK_PERIOD); // Debounce behaviour 
			store=0; #(CLOCK_PERIOD); // (value should not be stored)
			store=1; #(CLOCK_PERIOD);
			store=0; #(debouncer_stable_time); // Store the current value 5A
			store=1; #(debouncer_stable_time);
			SW[7:0]=8'b1010_0101; #5000 // Change switches to A5
			SW[9:8]=2'b10; #(delay) // Set to stored value mode
			assert(UUT.in3===16'b0000_0000_1001_0000) else $error("Stored value mode (decimal) failed expected in3=16'b0000_0000_1001_0000 recieved in3=%b", UUT.in3);
			// Hexadecimal storage
			SW[9:8]=2'b01; // Set to hexadecimal mode
			SW[7:0]=8'b1111_1111; #5000; // FF
			store=1; #(CLOCK_PERIOD); // Debounce behaviour
			store=0; #(CLOCK_PERIOD); // (value should not be stored)
			store=1; #(CLOCK_PERIOD);
			store=0; #(debouncer_stable_time); // Store the current value FF
			store=1; #(debouncer_stable_time);
			SW[7:0]=8'b0000_0000; #5000 // Change switches to 00
			SW[9:8]=2'b10; #(delay) // Set to stored value mode
			assert(UUT.in3===16'b0000_0000_1111_1111) else $error("Stored value mode (hexadecimal) failed expected in3=16'b0000_0000_1111_1111 recieved in3=%b", UUT.in3);

		$display("End of storage mode test");
		// Fixed output value tests
		SW[9:8]=2'b11; // Set to fixed output mode
		#(delay);
		assert(UUT.MUX4TO1_ins.mux_out===16'b0101_1010_0101_1010) else $error("Fixed value mode failed expected mux_out=16'b0101_1010_0101_1010 received mux_out=%b",UUT.MUX4TO1_ins.mux_out);
		$display("End of fixed output mode test");
		
		$display("\n===  Testbench ended  ===");
		$stop; // this stops simulation, needed because clk runs forever
	end
	
endmodule